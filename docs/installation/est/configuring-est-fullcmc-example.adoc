= Configuring EST fullcmc - Example
:toc:

== Overview

This document provides step-by-step instructions for setting up PKI CA and EST subsystems with EST fullcmc support, based on actual working configuration.

=== Architecture

----
Client                    EST Subsystem              CA Subsystem
  |                             |                          |
  | 1. Generate CSR             |                          |
  | 2. Wrap in CMC (CMCRequest) |                          |
  | 3. POST to /fullcmc ------->|                          |
  |    (TLS client cert auth)   |                          |
  |                             | 4. Forward CMC request ->|
  |                             |    (EST subsystem cert)  |
  |                             |    (Client cert in hdr)  |
  |                             |                          | 5. Authenticate EST subsystem (tier 1)
  |                             |                          | 6. Validate client cert from header (tier 2)
  |                             |                          | 7. Process CMC, issue cert
  |                             |<- 8. CMC response -------'
  |<- 9. CMC response ----------'                          |
  | 10. Extract certificate     |                          |
----

*Two-Tier Authentication:*

* *Tier 1*: EST subsystem authenticates to CA using its subsystem certificate
* *Tier 2*: CA validates the end-user's certificate passed via HTTP header

*Key Point*: The client manually creates the CMC request using the `CMCRequest` tool. EST does NOT wrap the CSR - it simply forwards the pre-wrapped CMC request to the CA. (This first-phase implementation leverages existing CA CMC support; future enhancements may add RA identity verification per IDM-4394.)

== Prerequisites

* Fedora system with PKI packages installed
* 389 Directory Server (389-ds-base package)
* Root access
* CMC tools (CMCRequest, CMCResponse) available in pki-tools package

== Part 1: Install 389 Directory Server Instances

=== Step 1: Install 389-ds-base

As root:

[source,bash]
----
dnf install -y 389-ds-base
----

=== Step 2: Create Working Directory

[source,bash]
----
mkdir -p /root/dogtag/ds
cd /root/dogtag/ds
----

=== Step 3: Create DS Instance for CA

Create `/root/dogtag/ds/dir-ca.inf`:

[source,ini]
----
[general]
full_machine_name = pki.example.com

[slapd]
instance_name = dir-ca
port = 2389
root_password = Secret.123
secure_port = 2636
self_sign_cert = True

[backend-userroot]
create_suffix_entry = True
suffix = dc=ca,dc=pki,dc=example,dc=com
----

Create the instance:

[source,bash]
----
dscreate from-file /root/dogtag/ds/dir-ca.inf
----

=== Step 4: Create DS Instance for EST

Create `/root/dogtag/ds/dir-est.inf`:

[source,ini]
----
[general]
full_machine_name = pki.example.com

[slapd]
instance_name = dir-est
port = 4389
root_password = Secret.123
secure_port = 4636
self_sign_cert = True

[backend-userroot]
create_suffix_entry = True
suffix = dc=est,dc=pki,dc=example,dc=com
----

Create the instance:

[source,bash]
----
dscreate from-file /root/dogtag/ds/dir-est.inf
----

=== Step 5: Setup EST DS Structure

Import the organizational structure:

[source,bash]
----
ldapadd -x -H ldap://localhost:4389 -D "cn=Directory Manager" -w Secret.123 \
    -c -f /usr/share/pki/est/conf/realm/ds/create.ldif
----

NOTE: The `-c` flag tells ldapadd to continue on errors. You may see "Already exists (68)" error for the base DN `dc=est,dc=pki,dc=example,dc=com` if `create_suffix_entry = True` was set in the DS configuration. This is normal - ldapadd will continue and create the remaining entries (ou=people, ou=groups, and cn=EST Users).

Verify the structure was created:

[source,bash]
----
ldapsearch -x -H ldap://localhost:4389 -D "cn=Directory Manager" -w Secret.123 \
    -b "dc=est,dc=pki,dc=example,dc=com" -s one dn
----

You should see:
----
dn: ou=people,dc=est,dc=pki,dc=example,dc=com
dn: ou=groups,dc=est,dc=pki,dc=example,dc=com
----

Verify the EST Users group:

[source,bash]
----
ldapsearch -x -H ldap://localhost:4389 -D "cn=Directory Manager" -w Secret.123 \
    -b "ou=groups,dc=est,dc=pki,dc=example,dc=com" -s one dn
----

You should see:
----
dn: cn=EST Users,ou=groups,dc=est,dc=pki,dc=example,dc=com
----

== Part 2: Install PKI CA Subsystem

=== Step 6: Create CA Working Directory

[source,bash]
----
mkdir -p /root/dogtag/pki-ca
cd /root/dogtag/pki-ca
----

=== Step 7: Create CA Configuration

Create `/root/dogtag/pki-ca/ca.cfg`:

[source,ini]
----
[DEFAULT]
pki_instance_name=pki-ca
pki_https_port=8443
pki_http_port=8080
pki_server_database_password=Secret.123

[Tomcat]
pki_ajp_port=8009
pki_tomcat_server_port=8005

[CA]
pki_admin_email=caadmin@example.com
pki_admin_name=caadmin
pki_admin_nickname=caadmin
pki_admin_password=Secret.123
pki_admin_uid=caadmin

pki_client_pkcs12_password=Secret.123

pki_ds_url=ldap://pki.example.com:2389
pki_ds_base_dn=dc=ca,dc=pki,dc=example,dc=com
pki_ds_database=ca
pki_ds_password=Secret.123

pki_security_domain_name=EXAMPLE

pki_ca_signing_nickname=ca_signing
pki_ocsp_signing_nickname=ca_ocsp_signing
pki_audit_signing_nickname=ca_audit_signing
pki_sslserver_nickname=sslserver
pki_subsystem_nickname=subsystem
----

=== Step 8: Install CA

[source,bash]
----
pkispawn -f /root/dogtag/pki-ca/ca.cfg -s CA
----

The CA admin certificate will be exported to `/root/.dogtag/pki-ca/ca_admin_cert.p12`.

=== Step 9: Setup CA Admin User

After installation, the admin certificate and key are stored in `~/.dogtag/pki-ca/ca_admin_cert.p12`.

To use the admin certificate, do the following:

. As root, export the CA signing certificate from the server NSS database and copy it to the working directory:
+
[source,bash]
----
# pki-server cert-export ca_signing --cert-file /tmp/ca_signing.crt -i pki-ca
# chmod 644 /tmp/ca_signing.crt
# cp /tmp/ca_signing.crt /root/dogtag/pki-ca/
----

. As regular user, copy the CA signing certificate to your working directory and import it into the client NSS database:
+
[source,bash]
----
cp /tmp/ca_signing.crt ~/.dogtag/pki-ca/
pki nss-cert-import --cert ~/.dogtag/pki-ca/ca_signing.crt --trust CT,C,C ca_signing
----

. Import the admin certificate and key into the client NSS database (by default ~/.dogtag/nssdb):
+
[source,bash]
----
pki pkcs12-import \
    --pkcs12 ~/.dogtag/pki-ca/ca_admin_cert.p12 \
    --password Secret.123
----

. Verify that the admin certificate can be used to access the CA subsystem:
+
[source,bash]
----
pki -n caadmin ca-user-show caadmin
----
+
NOTE: The `pki` command uses `~/.dogtag/nssdb` as the default NSS database directory. If you need to use a different NSS database location, specify it with the `-d` parameter.

=== Step 10: Verify EST fullcmc Profile

Verify that the `estFullEnrollment` profile exists:

[source,bash]
----
pki -n caadmin ca-profile-show estFullEnrollment
----

This profile should have been created during CA installation or upgrade. If it doesn't exist, EST fullcmc will not function.

[IMPORTANT]
====
The `estFullEnrollment` profile uses the `RAHeaderClientCertSubjectNameConstraint` constraint, which is **mandatory** for the two-tier authorization model. This constraint enables:

* **Non-agent enrollment**: The client's certificate subject must match the requested certificate subject
* **Agent enrollment**: CA agents can request certificates with any subject name

The constraint automatically detects the user's role by checking membership in the CA's "Certificate Manager Agents" group. Without this constraint:

* The profile cannot differentiate between agents and non-agents
* All EST users are subject to the same authorization rules
* Agent-based enrollment workflows (where agents request arbitrary subject names) will not function

While an administrator could theoretically create a custom profile without this constraint, doing so would eliminate the agent/non-agent differentiation that is central to the EST fullcmc design.
====

You can verify the constraint is present:

[source,bash]
----
pki -n caadmin ca-profile-show estFullEnrollment | grep -A2 "constraint.class"
----

You should see `RAHeaderClientCertSubjectNameConstraint` in the output.

=== Step 11: Configure CA for EST CMC Responses

IMPORTANT: The `cmc.response.useSimpleOnSuccess` parameter changes CMC response behavior for **all** CMC requests handled by this CA, not just EST. Setting it to `true` makes the CA return simple (non-full) CMC responses on successful enrollment, which is required for EST RFC compliance but may affect other CMC clients.

As root, edit `/var/lib/pki/pki-ca/ca/conf/CS.cfg` and add:

[source,properties]
----
cmc.response.useSimpleOnSuccess=true
----

Restart the CA:

[source,bash]
----
pki-server restart pki-ca
----

NOTE: For existing CA installations, the upgrade script automatically adds this parameter with the default value `false` to preserve existing CMC behavior. Administrators must manually change it to `true` to enable EST fullcmc support. For new installations, this parameter could be manually added and set to `true` if EST fullcmc support is needed.

== Part 3: Install EST Subsystem

=== Step 12: Create EST Working Directory

[source,bash]
----
mkdir -p /root/dogtag/pki-est
cd /root/dogtag/pki-est
----

=== Step 13: Create EST Configuration

Create `/root/dogtag/pki-est/pki-est.cfg`:

[source,ini]
----
[DEFAULT]
pki_instance_name=pki-est
pki_https_port=15443
pki_http_port=15080
pki_server_database_password=Secret.123
pki_admin_setup=False

[Tomcat]
pki_ajp_port=15009
pki_tomcat_server_port=15005

[EST]
est_realm_type=ds
est_realm_url=ldap://pki.example.com:4389
est_realm_bind_password=Secret.123
est_realm_users_dn=ou=people,dc=est,dc=pki,dc=example,dc=com
est_realm_groups_dn=ou=groups,dc=est,dc=pki,dc=example,dc=com

pki_sslserver_nickname=sslserver
pki_subsystem_nickname=subsystem

# Security Domain (from pki-ca)
pki_security_domain_hostname=pki.example.com
pki_security_domain_https_port=8443
pki_security_domain_name=EXAMPLE
pki_security_domain_user=caadmin
pki_security_domain_password=Secret.123

# CA connection
pki_ca_uri=https://pki.example.com:8443
----

=== Step 14: Install EST

[source,bash]
----
pkispawn -f /root/dogtag/pki-est/pki-est.cfg -s EST \
    -D pki_cert_chain_path=/root/dogtag/pki-ca/ca_signing.crt \
    -D pki_cert_chain_nickname=ca_signing
----

The installation will complete with a message showing the EST subsystem URL. For fullcmc requests, use the `/fullcmc` endpoint:

----
https://pki.example.com:15443/.well-known/est/fullcmc
----

Verify EST is running:

[source,bash]
----
curl -k https://pki.example.com:15443/.well-known/est/
----

You should see:

[source,json]
----
{
  "id" : "est",
  "name" : "Enrollment over Secure Transport",
  "path" : "/.well-known/est"
}
----

=== Step 15: Verify EST Backend Configuration

After installation, the EST backend configuration for fullcmc support is in `/var/lib/pki/pki-est/est/conf/backend.conf`. Verify that it contains the following:

[source,properties]
----
class=org.dogtagpki.est.DogtagRABackend
url=https://pki.example.com:8443
profile=estServiceCert

# Profile for /fullcmc endpoint (specifies which CA profile to use for fullcmc requests)
fullcmc.profile=estFullcmcDeviceCert
----

The `fullcmc.profile` parameter tells EST which CA profile to use when forwarding fullcmc requests. This should already be present in a fresh installation with fullcmc support, or added by the upgrade script for existing installations.

== Part 4: Create Test Users for fullcmc

The EST fullcmc endpoint supports two enrollment scenarios:

. *Non-agent enrollment*: The client's certificate subject must match the requested certificate subject.
. *Agent enrollment*: A CA agent can request certificates with any subject name.

We'll create test users for both scenarios.

=== Step 16: Create Non-Agent Test User

As regular user:

[source,bash]
----
mkdir -p ~/dogtag/fullcmc-test
cd ~/dogtag/fullcmc-test

# Generate key and CSR
openssl req -newkey rsa:2048 -nodes \
    -keyout est-nonrole-user.key \
    -out est-nonrole-user.csr \
    -subj "/UID=est-nonrole-user/CN=EST NonRole User"

# Submit to CA
pki ca-cert-request-submit \
    --profile caUserCert \
    --csr-file est-nonrole-user.csr \
    --subject "UID=est-nonrole-user,CN=EST NonRole User"
----

Note the request ID from the output, then as CA admin, approve and export:

[source,bash]
----
cd ~/dogtag/fullcmc-test

NONROLE_REQ_ID=<request_id_from_above>
pki -d ~/.dogtag/nssdb -n caadmin ca-cert-request-approve $NONROLE_REQ_ID

# Note the Certificate ID from the approval output above, then export:
NONROLE_CERT_ID=<certificate_id_from_approval_output>
pki -d ~/.dogtag/nssdb -n caadmin ca-cert-export $NONROLE_CERT_ID --output-file est-nonrole-user.crt
----

NOTE: You may see `WARNING: BAD_CERT_DOMAIN encountered on 'CN=pki.example.com,...'` warnings when running pki commands. This occurs because the CA certificate's common name is `pki.example.com` but you may be connecting via a different hostname (like `localhost`). This is expected in test/development environments and can be safely ignored.

=== Step 17: Add Non-Agent User to EST LDAP

As LDAP administrator:

[source,bash]
----
cd ~/dogtag/fullcmc-test

# Import certificate into temporary NSS database for processing
mkdir -p ~/dogtag/fullcmc-test/nssdb-temp
certutil -N -d ~/dogtag/fullcmc-test/nssdb-temp -f <(echo "Secret.123")
certutil -A -d ~/dogtag/fullcmc-test/nssdb-temp -n "est-nonrole-user" \
    -t ",," -i est-nonrole-user.crt -f <(echo "Secret.123")

# Get certificate details using certutil for correct formatting
CERT_SERIAL_HEX=$(certutil -L -d ~/dogtag/fullcmc-test/nssdb-temp -n "est-nonrole-user" | \
    grep -A1 "Serial Number:" | tail -1 | tr -d ' :' | tr -d '\n')
CERT_SERIAL_DEC=$(python3 -c "print(int('${CERT_SERIAL_HEX}', 16))")
CERT_ISSUER=$(certutil -L -d ~/dogtag/fullcmc-test/nssdb-temp -n "est-nonrole-user" | \
    grep "Issuer:" | sed 's/.*Issuer: "\(.*\)"/\1/')
CERT_SUBJECT=$(certutil -L -d ~/dogtag/fullcmc-test/nssdb-temp -n "est-nonrole-user" | \
    grep "Subject:" | sed 's/.*Subject: "\(.*\)"/\1/')

# Convert certificate to DER and base64
openssl x509 -in est-nonrole-user.crt -outform DER -out est-nonrole-user.der
CERT_B64=$(base64 -w 0 est-nonrole-user.der)

echo "CERT_SERIAL_DEC: $CERT_SERIAL_DEC"
echo "CERT_ISSUER: $CERT_ISSUER"
echo "CERT_SUBJECT: $CERT_SUBJECT"
echo "CERT_B64: $CERT_B64"

# Clean up temporary NSS database
rm -rf ~/dogtag/fullcmc-test/nssdb-temp
----

Create `~/dogtag/fullcmc-test/est-nonrole-user.ldif` with the certificate details from above:

[source,ldif]
----
dn: uid=est-nonrole-user,ou=people,dc=est,dc=pki,dc=example,dc=com
objectClass: top
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
uid: est-nonrole-user
cn: EST NonRole User
sn: User
userPassword: Secret.123
description: 2;<CERT_SERIAL_DEC>;<CERT_ISSUER>;<CERT_SUBJECT>
userCertificate:: <CERT_B64>
----

Add the entry to LDAP:

[source,bash]
----
ldapadd -x -H ldap://localhost:4389 -D "cn=Directory Manager" -w Secret.123 \
    -f ~/dogtag/fullcmc-test/est-nonrole-user.ldif
----

Create `~/dogtag/fullcmc-test/est-nonrole-user-group-add.ldif`:

[source,ldif]
----
dn: cn=EST Users,ou=groups,dc=est,dc=pki,dc=example,dc=com
changetype: modify
add: uniqueMember
uniqueMember: uid=est-nonrole-user,ou=people,dc=est,dc=pki,dc=example,dc=com
----

Add to EST Users group:

[source,bash]
----
ldapmodify -x -H ldap://localhost:4389 -D "cn=Directory Manager" -w Secret.123 \
    -f ~/dogtag/fullcmc-test/est-nonrole-user-group-add.ldif
----

Verify the user was created and added to the group:

[source,bash]
----
# Verify user exists
ldapsearch -x -H ldap://localhost:4389 -D "cn=Directory Manager" -w Secret.123 \
    -b "uid=est-nonrole-user,ou=people,dc=est,dc=pki,dc=example,dc=com" -LLL dn

# Verify user is in EST Users group
ldapsearch -x -H ldap://localhost:4389 -D "cn=Directory Manager" -w Secret.123 \
    -b "cn=EST Users,ou=groups,dc=est,dc=pki,dc=example,dc=com" -LLL uniqueMember
----

You should see:

----
dn: uid=est-nonrole-user,ou=people,dc=est,dc=pki,dc=example,dc=com

uniqueMember: uid=est-nonrole-user,ou=people,dc=est,dc=pki,dc=example,dc=com
----

=== Step 18: Create CA Agent Test User

As regular user:

[source,bash]
----
cd ~/dogtag/fullcmc-test

# Generate key and CSR
openssl req -newkey rsa:2048 -nodes \
    -keyout est-ca-agent.key \
    -out est-ca-agent.csr \
    -subj "/UID=est-ca-agent/CN=EST CA Agent User"

# Submit to CA
pki ca-cert-request-submit \
    --profile caUserCert \
    --csr-file est-ca-agent.csr \
    --subject "UID=est-ca-agent,CN=EST CA Agent User"
----

Note the request ID from the output, then as CA admin, approve and export:

[source,bash]
----
AGENT_REQ_ID=<request_id_from_above>
pki -d ~/.dogtag/nssdb -n caadmin ca-cert-request-approve $AGENT_REQ_ID

# Note the Certificate ID from the approval output above, then export:
AGENT_CERT_ID=<certificate_id_from_approval_output>
pki -d ~/.dogtag/nssdb -n caadmin ca-cert-export $AGENT_CERT_ID --output-file est-ca-agent.crt
----

=== Step 19: Add Agent Certificate to CA User and Agent Group

As CA admin:

[source,bash]
----
# Create user in CA
pki -d ~/.dogtag/nssdb -n caadmin ca-user-add est-ca-agent --fullName "EST CA Agent User"

# Add cert to CA user
pki -d ~/.dogtag/nssdb -n caadmin ca-user-cert-add est-ca-agent --input est-ca-agent.crt

# Add to Certificate Manager Agents group
pki -d ~/.dogtag/nssdb -n caadmin ca-group-member-add "Certificate Manager Agents" est-ca-agent
----

=== Step 20: Add Agent User to EST LDAP

As LDAP administrator:

[source,bash]
----
cd ~/dogtag/fullcmc-test

# Import certificate into temporary NSS database for processing
mkdir -p ~/dogtag/fullcmc-test/nssdb-temp
certutil -N -d ~/dogtag/fullcmc-test/nssdb-temp -f <(echo "Secret.123")
certutil -A -d ~/dogtag/fullcmc-test/nssdb-temp -n "est-ca-agent" \
    -t ",," -i est-ca-agent.crt -f <(echo "Secret.123")

# Get certificate details using certutil for correct formatting
CERT_SERIAL_HEX=$(certutil -L -d ~/dogtag/fullcmc-test/nssdb-temp -n "est-ca-agent" | \
    grep -A1 "Serial Number:" | tail -1 | tr -d ' :' | tr -d '\n')
CERT_SERIAL_DEC=$(python3 -c "print(int('${CERT_SERIAL_HEX}', 16))")
CERT_ISSUER=$(certutil -L -d ~/dogtag/fullcmc-test/nssdb-temp -n "est-ca-agent" | \
    grep "Issuer:" | sed 's/.*Issuer: "\(.*\)"/\1/')
CERT_SUBJECT=$(certutil -L -d ~/dogtag/fullcmc-test/nssdb-temp -n "est-ca-agent" | \
    grep "Subject:" | sed 's/.*Subject: "\(.*\)"/\1/')

# Convert certificate to DER and base64
openssl x509 -in est-ca-agent.crt -outform DER -out est-ca-agent.der
CERT_B64=$(base64 -w 0 est-ca-agent.der)

echo "CERT_SERIAL_DEC: $CERT_SERIAL_DEC"
echo "CERT_ISSUER: $CERT_ISSUER"
echo "CERT_SUBJECT: $CERT_SUBJECT"
echo "CERT_B64: $CERT_B64"

# Clean up temporary NSS database
rm -rf ~/dogtag/fullcmc-test/nssdb-temp
----

Create `~/dogtag/fullcmc-test/est-ca-agent.ldif` with the certificate details from above:

[source,ldif]
----
dn: uid=est-ca-agent,ou=people,dc=est,dc=pki,dc=example,dc=com
objectClass: top
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
uid: est-ca-agent
cn: EST CA Agent User
sn: User
userPassword: Secret.123
description: 2;<CERT_SERIAL_DEC>;<CERT_ISSUER>;<CERT_SUBJECT>
userCertificate:: <CERT_B64>
----

Add the entry to LDAP:

[source,bash]
----
ldapadd -x -H ldap://localhost:4389 -D "cn=Directory Manager" -w Secret.123 \
    -f ~/dogtag/fullcmc-test/est-ca-agent.ldif
----

Create `~/dogtag/fullcmc-test/est-ca-agent-group-add.ldif`:

[source,ldif]
----
dn: cn=EST Users,ou=groups,dc=est,dc=pki,dc=example,dc=com
changetype: modify
add: uniqueMember
uniqueMember: uid=est-ca-agent,ou=people,dc=est,dc=pki,dc=example,dc=com
----

Add to EST Users group:

[source,bash]
----
ldapmodify -x -H ldap://localhost:4389 -D "cn=Directory Manager" -w Secret.123 \
    -f ~/dogtag/fullcmc-test/est-ca-agent-group-add.ldif
----

== Part 5: Test EST fullcmc Enrollment

=== Step 21: Test Non-Agent Enrollment (Matching Subject)

As regular user:

[source,bash]
----
cd ~/dogtag/fullcmc-test

# Create CSR with SAME subject as est-nonrole-user cert
pki nss-cert-request --csr device1.csr \
    --ext /usr/share/pki/tools/examples/certs/device.conf \
    --subject 'UID=est-nonrole-user,CN=EST NonRole User'

# Convert to base64-encoded DER format (without PEM headers)
openssl req -in device1.csr -outform der | openssl base64 -out device1.p10
----

Create NSS database with test user certificate:

[source,bash]
----
mkdir -p ~/dogtag/fullcmc-test/nssdb-nonrole
certutil -N -d ~/dogtag/fullcmc-test/nssdb-nonrole -f <(echo "Secret.123")

# Import CA cert (exported in Step 9)
certutil -A -d ~/dogtag/fullcmc-test/nssdb-nonrole -n "CA Signing" -t "CT,C,C" \
    -i ~/.dogtag/pki-ca/ca_signing.crt -f <(echo "Secret.123")

# Import est-nonrole-user cert
openssl pkcs12 -export -in est-nonrole-user.crt -inkey est-nonrole-user.key \
    -out est-nonrole-user.p12 -name est-nonrole-user -passout pass:Secret.123
pk12util -i est-nonrole-user.p12 -d ~/dogtag/fullcmc-test/nssdb-nonrole -W Secret.123 -K Secret.123
----

Create `est-nonrole-user-cmc-req.cfg`:

[source,properties]
----
# NSS database directory where user certificate is stored
dbdir=nssdb-nonrole

# NSS database password
password=Secret.123

# Token name (default is internal)
tokenname=internal

# Nickname for signing certificate
nickname=est-nonrole-user

# Request format: pkcs10 or crmf
format=pkcs10

# Total number of PKCS10 requests
numRequests=1

# Path to the PKCS10 request (base64 encoded)
input=device1.p10

# Path for the CMC request output
output=device1-cmc.req
----

Generate CMC request:

[source,bash]
----
CMCRequest est-nonrole-user-cmc-req.cfg
----

Submit to EST fullcmc endpoint:

[source,bash]
----
curl -k \
    --cacert ~/.dogtag/pki-ca/ca_signing.crt \
    --cert est-nonrole-user.crt \
    --key est-nonrole-user.key \
    -H "Content-Type: application/pkcs7-mime; smime-type=CMC-request" \
    --data-binary @device1-cmc.req \
    https://pki.example.com:15443/.well-known/est/fullcmc \
    -o device1-cmc-response.b64
----

Extract certificate:

[source,bash]
----
# Decode base64 response to DER format
AtoB device1-cmc-response.b64 device1-cmc-response.der

# Extract certificate using CMCResponse tool
CMCResponse -d nssdb-nonrole -i device1-cmc-response.der

# Or manually extract using openssl
openssl pkcs7 -inform DER -in device1-cmc-response.der -print_certs -out device1-cert.pem
openssl x509 -in device1-cert.pem -noout -text
----

This should succeed because the CSR subject (`CN=EST NonRole User`) matches the client certificate subject.

=== Step 22: Test Non-Agent Enrollment (Mismatched Subject - Expected Failure)

As regular user:

[source,bash]
----
cd ~/dogtag/fullcmc-test

# Create CSR with DIFFERENT subject than est-nonrole-user cert
pki nss-cert-request --csr device2.csr \
    --ext /usr/share/pki/tools/examples/certs/device.conf \
    --subject 'CN=Different Device'

# Convert to base64-encoded DER format (without PEM headers)
openssl req -in device2.csr -outform der | openssl base64 -out device2.p10
----

Create `est-nonrole-user-cmc-req-mismatch.cfg`:

[source,properties]
----
dbdir=nssdb-nonrole
password=Secret.123
tokenname=internal
nickname=est-nonrole-user
format=pkcs10
numRequests=1
input=device2.p10
output=device2-cmc.req
----

Generate CMC request:

[source,bash]
----
CMCRequest est-nonrole-user-cmc-req-mismatch.cfg
----

Submit to EST:

[source,bash]
----
curl -k \
    --cacert ~/.dogtag/pki-ca/ca_signing.crt \
    --cert est-nonrole-user.crt \
    --key est-nonrole-user.key \
    -H "Content-Type: application/pkcs7-mime; smime-type=CMC-request" \
    --data-binary @device2-cmc.req \
    https://pki.example.com:15443/.well-known/est/fullcmc \
    -o device2-cmc-response.b64
----

This should fail with a subject name mismatch error because the CSR subject (`CN=Different Device`) does not match the client certificate subject (`CN=EST NonRole User`).

=== Step 23: Test Agent Enrollment (Any Subject - Should Succeed)

As regular user:

[source,bash]
----
cd ~/dogtag/fullcmc-test

# Create CSR with ANY subject (different from agent cert)
pki nss-cert-request --csr device3.csr \
    --ext /usr/share/pki/tools/examples/certs/device.conf \
    --subject 'CN=Any Device Name'

# Convert to base64-encoded DER format (without PEM headers)
openssl req -in device3.csr -outform der | openssl base64 -out device3.p10
----

Create NSS database with agent certificate:

[source,bash]
----
mkdir -p ~/dogtag/fullcmc-test/nssdb-agent
certutil -N -d ~/dogtag/fullcmc-test/nssdb-agent -f <(echo "Secret.123")

# Import CA cert (exported in Step 9)
certutil -A -d ~/dogtag/fullcmc-test/nssdb-agent -n "CA Signing" -t "CT,C,C" \
    -i ~/.dogtag/pki-ca/ca_signing.crt -f <(echo "Secret.123")

# Import est-ca-agent cert
openssl pkcs12 -export -in est-ca-agent.crt -inkey est-ca-agent.key \
    -out est-ca-agent.p12 -name est-ca-agent -passout pass:Secret.123
pk12util -i est-ca-agent.p12 -d ~/dogtag/fullcmc-test/nssdb-agent -W Secret.123 -K Secret.123
----

Create `est-ca-agent-cmc-req.cfg`:

[source,properties]
----
dbdir=nssdb-agent
password=Secret.123
tokenname=internal
nickname=est-ca-agent
format=pkcs10
numRequests=1
input=device3.p10
output=device3-cmc.req
----

Generate CMC request:

[source,bash]
----
CMCRequest est-ca-agent-cmc-req.cfg
----

Submit to EST:

[source,bash]
----
curl -k \
    --cacert ~/.dogtag/pki-ca/ca_signing.crt \
    --cert est-ca-agent.crt \
    --key est-ca-agent.key \
    -H "Content-Type: application/pkcs7-mime; smime-type=CMC-request" \
    --data-binary @device3-cmc.req \
    https://pki.example.com:15443/.well-known/est/fullcmc \
    -o device3-cmc-response.b64
----

Extract certificate:

[source,bash]
----
# Decode base64 response to DER format
AtoB device3-cmc-response.b64 device3-cmc-response.der

# Extract certificate using CMCResponse tool
CMCResponse -d nssdb-agent -i device3-cmc-response.der

# Or manually extract using openssl
openssl pkcs7 -inform DER -in device3-cmc-response.der -print_certs -out device3-cert.pem
openssl x509 -in device3-cert.pem -noout -text
----

This should succeed even though the CSR subject (`CN=Any Device Name`) does not match the client certificate subject (`CN=EST CA Agent`), because the client is a CA agent and can request certificates with any subject name.

== Part 6: Verification

=== Verify Two-Tier Authentication in CA Logs

As root:

[source,bash]
----
tail -100 /var/lib/pki/pki-ca/logs/ca/debug.* | grep -i "CMCAuthForEST"
----

Look for:

. EST subsystem certificate authentication (tier 1)
. Client certificate extraction from header (tier 2)

=== Verify Certificate Details

As regular user:

[source,bash]
----
# Get serial number
DEVICE_SERIAL=$(openssl x509 -in device1-cert.pem -noout -serial | cut -d= -f2 | python3 -c "print(int(input(), 16))")

# Check in CA
pki -d ~/.dogtag/nssdb -n caadmin ca-cert-show $DEVICE_SERIAL
----

Verify the certificate was issued using the `estFullcmcDeviceCert` profile.

== Troubleshooting

=== EST Cannot Connect to CA

Check that the EST subsystem certificate is properly configured:

[source,bash]
----
# List certificates in EST NSS database
certutil -L -d /var/lib/pki/pki-est/alias

# Verify subsystem certificate is present
certutil -L -d /var/lib/pki/pki-est/alias -n "subsystem"
----

=== Client Certificate Not Found in EST LDAP

[source,bash]
----
ldapsearch -x -H ldap://localhost:4389 \
    -D "cn=Directory Manager" -w Secret.123 \
    -b "uid=est-nonrole-user,ou=people,dc=est,dc=pki,dc=example,dc=com" \
    userCertificate description
----

Verify the certificate description format matches exactly (no spaces after commas in DNs).

=== CMC Authentication Fails

Check CA logs:

[source,bash]
----
grep "CMCAuthForEST" /var/lib/pki/pki-ca/logs/ca/debug.*
----

Verify both authentication tiers are passing.

=== Authorization Failures

Check that:

. EST agent (`est-ca-agent`) is member of "Certificate Manager Agents" group in CA
. Test users are members of "EST Users" group in EST LDAP

== Summary

You now have a complete EST fullcmc setup with:

. Two 389 Directory Server instances (dir-ca on port 2389, dir-est on port 4389)
. PKI CA subsystem with EST fullcmc profile and authentication
. EST subsystem configured as RA
. Two-tier authentication (EST subsystem cert + client cert via header)
. Test users demonstrating both enrollment scenarios:
   * Non-agent: Subject must match between client cert and CSR
   * Agent: Can request any subject name
. Working fullcmc enrollment workflow
